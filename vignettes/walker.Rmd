---
title: "Efficient Bayesian linear regression with time-varying coefficients"
author: "Jouni Helske"
date: "29 June 2017"
output:
html_document: default
bibliography: walker.bib
link-citations: true
vignette: |
  %\VignetteIndexEntry{Efficient Bayesian generalized linear models with time-varying coefficients}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{rstan}
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(walker)
```

## Introduction

Dynamic regression models are extension to basic linear regression models where instead of constant but unknown regression coefficients, the underlying coefficients are assumed to vary over "time" according to random walk. These types of models allow robust modelling of phenomenas where the effect size of the predictor variables and the response variable can vary during the period of the study. The `R` [@R] package `walker` provides an efficient method for fully Bayesian inference of such models, where the main computations are performed using state-of-the-art Markov chain Monte Carlo (MCMC) algorithms provided by `Stan` [@stan, @rstan]. This also allows the straightforward use of many diagnostic and graphical tools provided by several `Stan` related `R` packages such as `ShinyStan` [@shinystan].

More specifically, the dynamic linear regression model is defined as
$$
\begin{aligned}
y_t &= x'_t \beta_t + \epsilon_t, \quad t = 1,\ldots, n\\
\beta_{t+1} &= \beta_t + \eta_t,
\end{aligned}
$$
where $y_t$ is the observation at time $t$, $x_t$ contains the corresponding predictor variables, $\beta_t$ is a $k$ dimensional vector of regression coefficients at time $t$, $\epsilon_t \sim N(0, \sigma^2_{\epsilon})$, and $\eta_t \sim N(0, D)$, with $D$ being $k \times k$ diagonal matrix with diagonal elements $\sigma^2_{i,\eta}$, $i=1,\ldots,k$. Denote the unknown parameters of the model by $\beta = (\beta'_1, \ldots, \beta'_n)'$ and $\sigma = (\sigma_{\epsilon}, \sigma_{1, \eta}, \ldots, \sigma_{k, \eta})$. We define priors for first $\beta_1$ as $N(\mu_{\beta_1}, \sigma_{\beta_1})$, and for $\sigma_i \sim N(\mu_{\sigma_i}, \sigma_{\sigma_i})$, $i=1,\ldots,k+1$, truncated to positive values, with slighly awful notation.

Although in principle writing dynamic linear regression model as above in `Stan` or `BUGS` [@bugs] language is straighforward, these standard implementations are computationally inefficient and prone to severe problems related to convergence of the underlying MCMC algorithm. For example in (block) Gibbs sampling approach we target the joint posterior $p(\beta, \sigma | y)$ by sampling from $p(\beta | \sigma, y)$ and $p(\sigma | \beta, y)$. But because of strong autocorrelations between the coeffients $\beta$ at different time points, as well as with the associated standard error parameters, this MCMC scheme can be very inefficient. Also, the total number of parameters to sample increase with number of data points $n$. Although the Hamiltonian Monte Carlo algoritms offered by `Stan` are typically more efficient exploring the posterior than Gibbs-type algorithms, we still encounter similar problems (see the illustration in next Section). 

An alternative solution used by `walker` is based on the marginalization of the regression coefficients $\beta$ during the MCMC sampling by using the Kalman filter. This provides fast and accurate inference of marginal posterior $p(\sigma | y)$. Then, the corresponding joint posterior $p(\sigma, \beta | y) = p(\beta | \sigma, y)p(\sigma | y)$ can be obtained by simulating the regression coefficients given marginal posterior of standard deviations. This sampling can be performed for example by simulation smoothing algorithm by @durbin-koopman2002. Note that we have opted to sample the $\beta$ parameters given $\sigma$'s, but it is also possible to obtain somewhat more accurate summary statistics such as mean and variance of these parameters by using the standard Kalman smoother for compution of $\textrm{E}(\beta| \sigma, y)$ and $\textrm{Var}(\beta| \sigma, y)$, and using the law of total expectation.

We will next illustrate the usage of `walker` on a simulated dataset, and then discuss extensions to simple random-walk linear regression model.

## Illustration

Let us consider a observations $y$ of length $n=250$, generated by random walk (i.e. time varying intercept) and two predictors. This is rather small problem, but it was chosen in order to make possible comparisons with the "naive" implementation. For larger problems (in terms of number of observations and especially number of predictors) it is very difficult to get naive implementation to work properly, as even after tweaking several parameters of the underlying MCMC sampler, one typically ends up with divergent transitions or low BMFI index, meaning that the results are not to be trusted. 

First we simulate the coefficients and the predictors:

```{r example}
set.seed(1)
n <- 100
beta1 <- cumsum(c(0.5, rnorm(n - 1, 0, sd = 0.05)))
beta2 <- cumsum(c(-1, rnorm(n - 1, 0, sd = 0.15)))
x1 <- rnorm(n, mean = 2)
x2 <- cos(1:n)
u <- cumsum(rnorm(n, 0, 0.5))
ts.plot(cbind(u, beta1 * x1, beta2 * x2), col = 1:3)
```

```{r observations}
signal <- u + beta1 * x1 + beta2 * x2
y <- rnorm(n, signal, 0.5)
ts.plot(cbind(signal, y), col = 1:2)
```

Then we can call function `walker`. The model is defined as a formula like in `lm`, and we can give several arguments which are passed to `sampling` method of `rstan`, such as number of iteration `iter` and number of chains `chains` (default values for these are 2000 and 4). In addition to these, we use arguments `beta_prior` and `sigma_prior`, which define the prior distributions for $\beta_1$ and $\sigma$ respectively. These arguments should be two-column matrices, where the first column defines the prior means, and the second column defines the prior standard deviations.

```{r walker}
kalman_walker <- walker(y ~ x1 + x2, refresh = 0, chains = 2,
  beta_prior = cbind(0, rep(5, 3)), sigma_prior = cbind(0, rep(2, 4)))
```

We sometimes get a few (typically one) warning message about numerical problems, as the sampling algorithm warms up, but this is nothing to be concerned with (if more errors occur, then a Github issue for `walker` package is more than welcome). 

The output of `walker` is `walker_fit` object, which is essentially a list with `stanfit` from `Stan`'s `sampling` function, and the original observations `y` and the covariate matrix `xreg`. Thus we can use all the ready made tools for postprocessing `stanfit` objects:

```{r pars}
print(kalman_walker$stanfit, pars = c("sigma_y", "sigma_b"))
library("bayesplot")
plot(kalman_walker$stanfit, pars = c("sigma_y", "sigma_b"))
```

Let's check how well our estimates of $\beta$ coincide with the true values (the solid lines correspond to true values):

```{r plot_with_true_betas}
betas <- summary(kalman_walker$stanfit, "beta")$summary[, "mean"]

ts.plot(cbind(u, beta1, beta2, matrix(betas, ncol = 3)),
  col = rep(1:3, 2), lty = rep(1:2, each = 3))
```

There is also simpler (and prettier) `ggplot` based plotting function for coefficients:

```{r plot_pretty_betas}
plot_coefs(kalman_walker)
```

We can perform the same analysis with naive implementation by setting the argument `naive` to `TRUE`:

```{r naive}
naive_walker <- walker(y ~ x1 + x2, seed = 1, refresh = 0, chains = 2,
  beta_prior = cbind(0, rep(5, 3)), sigma_prior = cbind(0, rep(2, 4)),
  naive = TRUE, control = list(adapt_delta = 0.9, max_treedepth = 15))
print(naive_walker$stanfit, pars = c("sigma_y", "sigma_b"))

sum(get_elapsed_time(kalman_walker$stanfit))
sum(get_elapsed_time(naive_walker$stanfit))
```

With naive implementation we get smaller effective sample sizes and much higher computation time, as well as some indications of divergence problems, even with adjusted step size (argument `adapt_delta`).

## Posterior predictive checks and out-of-sample predictions

The `walker` function also returns samples from the posterior predictive distribution $p(y^{\textrm{rep}} | y) = \int p(y^{\textrm{rep}} | \beta, \sigma, y) p(\beta, \sigma | y) \textrm{d}\beta\textrm{d}\sigma$. This can be used to used for example in assessment of model "fit" to the data. By comparing the replication series (mean and 95% quantiles in black) and the original observations (in red) we see that very good overlap, which is not that suprising given that we know the correct model:

```{r ppc}
pp_check(kalman_walker)
```

It is also possible to perform actual predictions given new covariates $x^{new}$ (Currently we need to run whole MCMC procedure for this but a separate function which uses the output of `walker` will likely be added in future).

```{r prediction}
original_data <- data.frame(y = head(y, 95), x1 = head(x1, 95), x2 = head(x2, 95))
new_data <- data.frame(x1 = tail(x1, 5), x2 = tail(x2, 5))
walker_predict <- walker(y ~ x1 + x2, data = original_data, newdata = new_data, 
  iter = 2000, chains = 1, seed = 1, refresh = 0,
  beta_prior = cbind(0, rep(2, 3)), sigma_prior = cbind(0, rep(2, 4)))
intervals <- summary(walker_predict$stanfit, pars = "y_new")$summary[, c("mean", "2.5%", "97.5%")]
ts.plot(ts(y), ts(intervals, start = 96),
  col = c(1, 2, 2, 2), lty = c(1, 1, 2, 2))
```

## Extensions: Smoother effects and non-Gaussian models

When modelling regression coefficients as a simple random walk, the posterior estimates of these coefficients can have large short-term variation which might not be realistic in practice. One way of imposing more smoothness for the estimates is to switch from random walk coefficients to integrated second order random walk coefficients:
$$
\beta_{t+1} = \beta_t + \nu_t,\\
\nu_{t+1} = \nu_t + \eta_t.
$$
This is essentially local linear trend model [@harvey] with restriction that there is no noise on the $\beta$ level. This model can be estimated with `walker_rw2` function, with identical interface, but now $\sigma$ correspond to the standard deviations of the slope terms $\nu$. The prior for $\nu$ is assumed $N(0, 10)$ by default. Using second order model, the coefficient estimates of our example model are clearly smoother:

```{r walker_rw2}
kalman_walker_rw2 <- walker_rw2(y ~ x1 + x2, refresh = 0, chains = 2,
  beta_prior = cbind(0, rep(5, 3)), sigma_prior = cbind(0, rep(2, 4)))
plot_coefs(kalman_walker_rw2)
```

So far we have focused on simple Gaussian linear regression. The above treatment cannot be directly extended to non-Gaussian models such as Poisson regression, as the marginal log-likelihood is intractable. However, it is possible to use relatively accurate Gaussian approximations, and the resulting approximate posterior can then be weighted using importance sampling type correction [@vihola-helske-franks], leading to exact inference. Currently function `walker_glm` can be used for Poisson observations, but straightforward extensions to binomial and negative binomial distributions are added in future. 


## Discussion

In this vignette we illustrated the benefits of marginalisation in the context of dynamic regression models. The underlying idea is not new; this approach is typical especially in classic Metropolis-type algorithms for linear-Gaussian state space models where the marginal likelihood $p(y | \theta)$ (where $\theta$ denotes the hyperparameters i.e. not the latents states such as $\beta$'s in current context) is used in the computation of the acceptance probability. Here instead of building specific MCMC machinery, we rely on readily available Hamiltonian Monte Carlo based `Stan` software, thus allowing us to enjoy the benefits of diverse tools of the `Stan` community. Due to the restricted class of models considered, we can also simplify the underlying Kalman filter considerably, thus enabling efficient likelihood evaluation.

## References
