% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/walker.R
\name{walker}
\alias{walker}
\title{Bayesian linear regression with random walk coefficients}
\usage{
walker(formula, data, sigma_y_prior, beta_prior, init, chains,
  return_x_reg = FALSE, ...)
}
\arguments{
\item{formula}{An object of class \code{\link[stats]{formula}}. See \code{\link[stats]{lm}} for details.}

\item{data}{An optional data.frame or object coercible to such, as in \code{\link[stats]{lm}}.}

\item{beta_prior}{A matrix with \eqn{k} rows and 2 columns, where first columns defines the 
prior means of the Gaussian priors of the corresponding \eqn{k} regression coefficients, 
and the second column defines the the standard deviations of those prior distributions.}

\item{init}{Initial value specification, see \code{\link[rstan]{sampling}}. 
Note that compared to default in \code{rstan}, here the default is a to sample from the priors.}

\item{chains}{Number of Markov chains. Default is 4.}

\item{return_x_reg}{If \code{TRUE}, does not perform sampling, but instead returns the matrix of 
predictors after processing the \code{formula}.}

\item{...}{Further arguments to \code{\link[rstan]{sampling}}.}

\item{sigma_prior}{A matrix with \eqn{k + 1} rows and two colums with similar structure as 
\code{beta_prior}, with first row corresponding to the prior of the standard deviation of the 
observation level noise, and rest of the rows define the priors for the standard deviations of 
random walk noise terms. The prior distributions for all sigmas are 
Gaussians truncated to positive real axis. For non-Gaussian models, this should contain only k rows. 
For second order random walk model, these priors correspond to the slope level standard deviations.}
}
\value{
A list containing the \code{stanfit} object, observations \code{y},
  and covariates \code{xreg} and \code{xreg_new}.
}
\description{
Function \code{walker} performs Bayesian inference of a linear 
regression model with time-varying, random walk regression coefficients, 
i.e. ordinary regression model where instead of constant coefficients the 
coefficients follow first or second order random walks. 
All Markov chain Monte Carlo computations are done using Hamiltonian 
Monte Carlo provided by Stan, using a state space representation of the model 
in order to marginalise over the coefficients for efficient sampling.
}
\note{
Beware of overfitting and identifiability issues. For example, one
might be tempted to use an intercept and time (1:n) as covariates, but if 
both coefficients are allowed to vary over time, this can lead to large uncertainty 
in posterior as these to components might not easily distinguishable.
}
\examples{

rw1_fit <- walker(Nile ~ -1 + 
  rw1(~ 1, 
    beta_prior = c(1000, 100), 
    sigma_prior = c(0, 100)), 
  sigma_y_prior = c(0, 100), 
  iter = 500, chains = 2)
  
rw2_fit <- walker(Nile ~ -1 + 
  rw2(~ 1,
    beta_prior = c(1000, 100), 
    sigma_prior = c(0, 100), 
    slope_prior = c(0, 100)), 
  sigma_y_prior = c(0, 100), 
  chains = 2)
  
g_y <- geom_point(data = data.frame(y = Nile, x = time(Nile)), 
  aes(x, y, alpha = 0.5), inherit.aes = FALSE) 
g_rw1 <- plot_coefs(rw1_fit) + g_y
g_rw2 <- plot_coefs(rw2_fit) + g_y
if(require("gridExtra")) {
  grid.arrange(g_rw1, g_rw2, ncol=2, top = "RW1 (left) versus RW2 (right)")
} else {
  g_rw1
  g_rw2
}

y <- window(log10(UKgas), end = time(UKgas)[100])
n <- 100
cos_t <- cos(2 * pi * 1:n / 4)
sin_t <- sin(2 * pi * 1:n / 4)
dat <- data.frame(y, cos_t, sin_t)
fit <- walker(y ~ -1 + 
  rw1(~ cos_t + sin_t, beta_prior = c(0, 10), sigma_prior = c(0, 2)), 
  sigma_y_prior = c(0, 10), data = dat, chains = 2, iter = 500)
print(fit$stanfit, pars = c("sigma_y", "sigma_rw1"))

plot_coefs(fit)
# posterior predictive check:
pp_check(fit)

newdata <- data.frame(
  cos_t = cos(2 * pi * 101:108 / 4), 
  sin_t = sin(2 * pi * 101:108 / 4))
pred <- predict(fit, newdata)
plot_predict(pred)

}
\seealso{
walker_rw2 walker_glm
}
